Ever sent out one resume after another and heard nothing back? No replies, no rejections, just silence. It's brutal. And it happens to everyone. Junior devs, senior devs, doesn't matter. But here's the thing. It's usually not that you're not good enough. It's that your resume isn't saying it loud enough or worse. You're applying blindly without knowing what the job actually wants. I'm Adrian and in this video we're building a serverless AI ré analyzer that shows you exactly how well your resume matches any job post and how to fix it. Think of it as your personal job search assistant coded by you. You'll learn how to handle off cloud and AI functionalities directly from your front end completely for free. That's unheard of. Securely upload résumés and job listings through file storage. analyze them instantly with free AI models. Yep, free GPT, Claude, and even Grock. Generate real time ATS scores and custom feedback, all while building a sleek, responsive UI that works beautifully on any device. And finally, deploy it with zero dollars in infrastructure costs, no matter how many users you have. It allows each user of your app to cover their own cost and not you. This is all possible thanks to Perjs, which gives you your own personal cloud computer with built-in O, storage, AI, and database. No backend, no setup, just code, completely free. But that's not all. You'll also learn real dev skills in ReactJS with the latest React Router V7, Tailwind CSS V4 for fast responsive styling, TypeScript for clean type- safe code, and Zastand for simple global state management. Plus, learning how to write code that's clean, scalable, and built for the real world. By the end, you'll have a polished, productionready tool that not only teaches you cutting edge skills, but also helps you land your dream job. This isn't another clone, but a real product with real impact. This is how you should learn and build the right way. So, let's make it loud. And once again, welcome to the AI ré analyzer course. In this course, I'll teach you how to build all of this. We'll start with a very simple authentication page and then very quickly we'll move over to the resume upload form where you can enter your name, the job you're applying for with the full job description, the years of experience that are required from you and then you can upload your resume. After you do that, I'll show you how you can use AI completely for free with no credit card required to assess your resume and provide detailed feedback. So, you'll be able to view it on your homepage and then head over to RSé review where you'll get detailed feedback on the four different categories that make up your resume such as the tone and style, content, structure, and the skills. How well do they match what the job description is talking about? you'll be able to scroll through all the different feedback, make improvements, and finally get that job. So, this isn't only a project in which you're going to learn a lot and be able to use free AI, but you'll also be able to optimize your own résumés. For this one, we'll switch things up a bit and use React to create our user interface from components, and then we'll use Pewer to handle the backend and AI stuff. Think of puter as running your own personal computer on the internet. But in this one specifically, I'll show you how to use puter.js, which allows you to bring serverless o cloud and AI services directly to your browser side JavaScript with no backend code or configuration required. To spin up our React project, we're going to use Vit. And instead of following the docs to get started, I'll show you how I spin up my projects. I use WebStorm to develop my projects. And I also used it back in the day when you actually had to pay for it. But as of recently, it became completely free for non-commercial use, which means that you get all the benefits of a powerful IDE completely for free. I'll leave the link down in the description so you can go ahead and download it. So later on whenever you see me use some cool features or shortcuts within my code editor, you'll know that it's actually a WebStorm IDE. Oh, and with WebStorm, I'll also show you how to use Juny, Jet Brains's smart coding agent that improves my productivity. So, you can also click the link down in the description and get it downloaded right away. Once you do that, let's go ahead and create a new project. I opened up WebStorm and I'll click new project. And now I'll just create a new empty project, which I'll call AI Rumé Analyzer. Click create and you'll be redirected right in. And you can notice that my web store might be looking a bit different from yours. That's because I set up a custom theme. I used material deep ocean and I also decided to hide the navigation bar and also all the other toolbars just so I have a clean view of my code. Oh, and don't forget I also set up Juny. So, if you press command shiftB and search for Juny, it should pop up right here on the right side. I'll show you how you can use it later on to improve your efficiency. But for now, let's set up our new Vit project. Head over to vit.dev and click get started and then scroll down to installation. First, we have to run mpm create vit latest. We can do that right within the terminal. So, just open it up and then paste it. but also add the dot at the end. This will make sure to create it in the current folder that you've opened and it's not going to create a new one for you. So, just press enter and then it'll ask you a couple of questions. First, say ignore files and continue. And then you have to select a framework. In this case, we're going with React. But now, we want to select a variant of React. And in this case, we're going to go with the React Router V7 variant. Finally, it'll ask you whether you want to install the create React Router. So say Y for yes. And then it'll ask you whether you also wanted to initialize a new Git repo to which I'll say yes, please do. And install all the dependencies with MPM so we can very easily run our application. Now, while the dependencies are getting installed, let's also set up our account on Pewtor. I'll leave the link down in the description. We'll use it later on to handle true serverless AI off and cloud directly within your front-end code. It's completely free and no credit card is required. So, just click the link down in the description and create a free account and you're in. See, we'll use Pewer to handle our resumes and provide feedback, but Pewer is actually much more than that. It's an advanced open-source internet operating system. Think of it as your own personal computer on the internet. You can use it to store all of your files or maybe like a platform for building different websites and apps. It can be an alternative to Google Drive or maybe just a remote desktop environment. In this video though, we won't be looking at puter.com. I'll teach you how to useJS. They're the pioneer of the user pays model which allows each user of your app to cover their own cost. This means that no matter how many users you have, it'll always cost you zero in infrastructure if you build with. I'll show you how to use it very soon. But for now, as our dependencies got installed, we can run mpm rundev to spin up our application on localhost 5173. And you'll be able to see a very simple and pretty plain React router boilerplate. So now that we got it installed, let me actually go over the app structure so that you understand what every single file and folder here does. We can start from the bottom at the vconfig.ts. This file contains vit configuration for the project. And you can see that we already have three plugins set up. Tailwind for styling, react router for routing, and typescript for type safety. Then there's the React router config which are configuration options for React router making use of the serverside rendering. Then there's the tsconfig file which contains the rules that TypeScript will use to enforce type safety throughout the project. There's also the package.json which contains all of our dependencies. You also get a docker file which v generates by default letting you host your app inside of a docker container. Then there's the getit ignore and docker ignore to make sure that you don't push any secrets to GitHub. And then there's also a public folder at the bottom which contains all of your assets, a node modules folder which contains all of your dependencies and some additional react router metadata which you don't have to dive into yourself. What we care most about is going to be within the app folder. It's the core of our application. Currently, it contains just the routes folder and the welcome directories, but as soon as we start building, we'll add more things to it like the lib and components. The app routes.ts is a React routers configuration file. Currently, it only contains one index route loading the homepage, but very soon we'll expand it. There's also the app root.tsx, which is the main entry point of the application. It contains the default layout and loads all the necessary scripts. All other pages are going to be passed as children to this page. It also contains some error boundaries so that whenever some errors occur, we can easily catch them. And then finally, there's the app.css which is the main CSS file for Tailwind. We're going to keep all of our custom classes here so the actual components won't get too cluttered. Right now, it's pretty empty, but I'll provide you with a ready file in the video kit. If you want to dive deeper into Tailwind, check out the ultimate Tailwind CSS v4 course on YouTube. Oh, and speaking of Tailwind, we're going to also use an additional package, which we have to install. So I will open up the terminal right here and I'll create another one which I will call terminal and I'll rename the first one to app because this one is currently running our app but we'll use the second one to install the additional dependencies. Now we can install this second package which is going to be only used in development called TWW as in Tailwind animate CSS. We'll use it for creating some cool Tailwind animations. Okay. And to be 100% ready to soon start working on the project, let's also install a few more packages we're going to use. I'll explain what all of them do once we get to them for the first time. So just run mpm install clsx tailwind- merge pdfjs dashist and zestad and just press enter. And just so we can finish the project setup and we can get started with building this application, we also need to get the assets needed to build this beautiful design. The assets include easy things like this favicon right here or maybe this icon right here at the top, maybe even this icon right here. You can get those assets completely free within the video kit down below. Alongside it, you can also get access to a completely free final source code that you can compare your code to if you get stuck, as well as a final Figma design. So, just click on the assets right here and download them from Google Drive. Once you do that, unzip them, and you'll be able to see a new public folder and then drag and drop all of your files directly within your current public folder. Then you'll notice that right here we have some SVGs as well as the images of different types of icons that we can use within our application. And finally, alongside the assets, we also need to grab some initial styles. You can find them right here within the snippets to copy app.css. So just press copy right here and then head over into your app app.css CSS and override what you have there. Right now, it might seem like we're initially adding a lot of styles, but the only thing we're doing is setting up some of the theme colors that I chose from the Figma design, as well as resetting some default elements like HTML on the body, as well as defining how the HTML elements within this application will look like, such as this H1, which will be very big, H2 a bit smaller, label will be dark, and so on. So later on as we're developing our application, it'll be much easier to just immediately write an input without having to pass all of these additional styles to it. But there are also some of the additional component styles like this text gradient or a primary button. Instead of every time specifying that a button should be of a primary gradient with a white text and full rounded, we can just define a class name and then use it later on. So whenever we do end up using it, I'll point you to this file so you can see the full styles. And if you want to learn a bit more about how to set up these Tailwind styles on your own, you can check out that free crash course on YouTube. And I'll also soon create a full Tailwind CSS course. With that said, we also have to install this TWW animate CSS because it's one of the packages we'll use. So if you haven't already, just install it as a dev dependency and the red squiggly line will be done. And that means that we're done with our setup. Everything is still looking exactly as it did before. But now we are ready to dive right into developing our homepage. Starting with the navigation bar, the hero section, and the list of different cards. Before we do that, let's actually go ahead and submit our current code to GitHub. So head over to github.com/new and add your repo name. I'll go with something like AI ré analyzer. We can leave everything as it is and just click create repository. Once you do that, we can follow the steps to push it over to the repo. So, let me actually put this browser side by side so we can refer to these different commands. And I'll open up our second terminal. First things first, run git init dot get commit-m first commit get branch- capital m main to change the branch and then copy this git remote add origin to point to this current repo and finally get push u origin main. These couple of commands will push all of your current code right to your own GitHub repo. And having that GitHub repo is super useful because you'll be able to track all of your commits starting from scratch and show your potential employers that you're actually developing this application on your own. Oh, and your contributions grid will thank you. So now that we've set up our file and folder structure and our development environment, we are ready to dive right into our first big lesson. Before we get started working on the homepage, let's first deal with the favicon and the title of our application. We can fix it if we head over to the app folder, then head over to routes and home.tsx. And here you can update the meta functions and the page. So instead of a new React router application, I'll call it resind. And you can notice that WebStorm doesn't think it's a real word. So I'll say, hey, save that to the dictionary. It's the name of our application. And then as the description, we can say something like smart feedback for your dream job. And then we can modify our homepage. instead of a welcome page, which I will remove right now. And I will just render a new main. So, you can immediately delete this welcome folder because we no longer need it. And once you do that, you'll notice that you're going to get some errors, and that's because we still had the import for it right here. But the app also thinks that we still need the logo dark that was used back in the welcome page. So once you delete it, you might need to reload your application by rerunning mpm rundev and then reloading your page. And then you'll be back to a completely blank new page. To make it not so blank, render a new section within this main and give it a class name equal to main section. And then within it also render a div with a class name equal to page heading. And within it, render an H1 that says track your applications and resume ratings. And now you can see this great looking heading below it. I'll also render an H2. And we can say something that we are saying in the design that's going to be something like review your submissions and check AI powered feedback. Great. Instead of having all of this be a wide screen, I'll also give this main a class name of bg dash and then within it in square brackets URL and then if you want to use string sides inside of it, you want to use double quoted strings outside and within this URL we can basically point to forward/ images/bg main.svg SVG and you can also give it a class name of BG cover. So now it has this nice looking gradient even in the background. So the page is looking great and we just made sure Tailwind is working. So now we can focus on our first real component of the day and that's of course going to be the navbar at the top and then immediately after we'll dive into creating these different ré cards just so we can immediately visualize it. And after we have the UI figured out, we'll then dive into authentication and actual logic for creating our resume reviews. So right within the app, create a new directory and call it components. Within the components folder, create a new file and call it navbar.tsx. Within it, just run rafce to quickly spin it up as a new react functional component with export. And then you can import it right within the homepage. I'll do it right above the hero section navbar. And if you save it, you can see it appear right here. So let's get started developing it. I'll turn this div into an HTML 5 semantic nav tag and then give it a class name equal to navbar. within it I'll display a link that's going to point to homepage forward slash and this link of course is coming from react router within this link I'll render a p tag that'll just say resmind and to style it a bit we can give it a class name equal to text-2 excel font-bold and text-g gradient so it looks a bit more a part of the entire application And beneath this link, I'll render yet another link. This one pointing to forward slashupload, which will appear on the other side of the navigation bar. And it'll say upload resume with a class name of primary button and w fit. And now we can see how easily we get this new UI. This primary button actually applied a series of different classes such as the primary gradient text white rounded full some paddings horizontal and vertical cursor pointer and W full. Everything makes sense. And believe it or not, that's it for our very simple minimalistic navbar. But now to make our homepage UI just a tiny bit more complete, let's head back over into the homepage. and I'm navigating over to it by pressing command and then P and typing the route I want to go to. It is much easier than opening up the file explorer and then finding it right here. And then below the section that has the text, I want to map over an array that contains different kinds of résumés. Within here, we'd need to map over some of the résumés or ré reviews that we have generated so far. Well, we haven't already, but let's imagine that later on they're going to appear right here. So, for sure, it's going to be some kind of an array that's going to have a list of different objects within it. Each one of these objects is going to have some kind of a title, right? And the title will be maybe a resume for JS Mastery if that's where you applied. alongside the title, we can have something else like a thumbnail and this is going to be a link to an image and so on. Right? But just so we don't clutter the view right here, we can also just make sure that this data is coming from somewhere else. Later on, it's going to be coming from the database. But just so we get the UI done, we can already create some mock data that's going to help us think about the database architecture later on. So this is the perfect use for a folder and a file called constants. Right within the root of our application, create a new folder and call it constants. Within constants, create a new file and call it index.ts. And now here you can create and export this new array. For example, export const résumés. And then this will be an array of a couple of different objects. Just so we don't have to go ahead and type them out by hand right now. If you head over to the video kit down below, and at this point I think you could just have it opened at all times, you'll be able to see a new constants index.ts file which you could just copy and paste over here. Even though it appears like there's a lot of stuff right here, you'll see that basically we have what I just explained. It's going to be an array of résumés that contains a couple of different résumés, in this case three. And it also contains this AI response format, which is just a string explanation of how later on we want AI to return the data to us. More on that later. For now, you can see that we have one red squiggly line right here saying that we don't know what this resume is. So, we have to define its type. Now, how do we define the types within our TypeScript applications? You could define it right here above as an interface by saying interface resume and then define that it'll have an ID of a type number or something else. For example, in this case, actually, it's a string as you can see below. But you don't necessarily have to define the types where they're first mentioned. We can define them within special files called declarations. So create a new folder within the root of the application and call it types. Within types create a new file and call it index d.ts. And now within here you can declare a new interface of ré and define it. And then later on it'll be automatically recognized within all of the other files. As you can see it's no longer complaining. It knows that it is coming from here, but I haven't yet defined how the structure needs to look like. So instead of us typing out all of these different properties, you can just find it right here in the snippets to copy and copy the app types index.d.ts and paste it right here. So you'll notice that we have the types for a couple of different things. primarily the resume which I was just talking to you about and then the feedback within that resume which is going to be the AI generated feedback that we want to receive from AI. And now if you head over to the constants you can see that you know exactly how each one of these résumés will look like. And now if you head back over to the homepage, instead of just creating your arrays right here, you can just say résumés, import them over from constants, map over them, and for each resume, you can automatically return something like a div that'll render an H1, and it'll render the résé. Title. So, if you head back over to your homepage, you can now see that we have three different résumés for front- end, cloud, and iOS development positions. Perfect. But now, let's make it look nicer. And let's not duplicate ourselves, but rather let's create a new reusable component for the ré card. So, head over to components and create a new component and call it ré card.tsx and run rafce. Now you can very easily import it right within the homepage. So instead of rendering a div with an H1, just render a resume card. Make sure to import it and to it provide a key since we're mapping over it equal to ré ID and also provide the entire resume. So we can then later use that data within that component. We can also put all of that within an additional container div with a class name of résumés section. And before we render that ré section, we first want to check if résé.length is greater than zero. If it is, then we render the résumés section. And within the résumé section, we map over the résumés. So at the end of the day, that's going to look something like this. And now you can head over into the ré card and start implementing its UI. The entire résé card itself will be just a link coming from React Router pointing to a new route. It's going to be forward slashres/ dynamic réid. So you have to wrap this in a pair of curly braces like this. And this ré of course is coming at the top. So we can dstructure résé from the props and say that the type of the résé is equal to résé coming from the types right here. Remember index.d.ts and now it knows that résé indeed has an ID which is of a type string. To this link we can provide a class name equal to réashcard. We can also give it animate dash in fade dash in throughout a duration of 1,000 milliseconds. This is a very easy way of applying simple animations directly through Tailwind. So now if you reload, you can see that it takes them about a second to fade in. Even though it's great for simple animations, it's going to come nowhere near what you can do with GSAP. And just recently, we published a full course where you can develop a GTA 6 landing page as well as many different case studies of how popular companies use animation to trigger emotion when you browse different websites. So, if you want to check that out, the link will be down in the description. Oh, and we have all of these animated examples to explain how animations truly work behind the scenes. But for now, let's add something within this link, such as a new div that has a class name equal to flex flex- call gap of two. And within it, we can then display an H2 with a class name equal to text-black. And we can make it important so it sticks and also font dash bold as well as break words so it nicely displays right here within the card. And there you can render the resume dot company name. So the name of the company that you want to present your resume below it. We can also render an H3 with a class name of text-LG break words and text-g gray 500. And within it, we can render the ré.job title. In case you don't want to repeat yourself and say ré dotres dot, you can just extract these different props from the resume right here by using object destructuring. So just say, "Hey, give me the ID, the company name, the job title. Do we need something else?" Well, maybe we can get the feedback out of it. And I think that's going to be good enough for now. And now instead of repeating resume, you can just say ID, company name, and job title. And all of it fits right here within a single line. Just some simple ways to make your code look nicer. Now finally below this div I'll render another div within which we want to show the score. This div will have a class name equal to flex-shrink-0 and within it we want to display some kind of an SVG circle that'll fill up the score as it gets higher. This is what I'm talking about. So we want to have some kind of an SVG circle and the higher the number is the higher the score rating will be. We can do this with SVG files, but to be able to pass additional info into that SVG, we have to create it as a React component. So within the components folder, create a new file and call it score circle.tsx. Then head over into the video kit and find this app component score circle and just copy it and then paste it right here. This is basically just an SVG component. You can see it right here. But alongside being just a regular SVG, we're also passing a score variable to it. So we can decide how filled it is. So just call it right here. That's going to be the score circle. And you'll have to pass in the score in this case of feedback dot overall score. And now if you save it and come back, you can see that we have different scores for these three different applications. And to make sure that these two look good together, we can wrap both of them in another div, which I'll call with a class name of ré card header. And now we can pass both of these two divs right within it. And it looks better. Now it's centered because we're in a very weird screen size. But as soon as you expand it a bit, you'll see that now it appears on left and right side. And of course, now the most important part below these two divs, we can render an image of this uploaded resume. First, I'll wrap it in a div with a class name of gradient border, animate in, fade in, throughout a duration of 1,00 milliseconds. Then within it, I'll display another div that'll have a class name of wful and h full. And within it, I'll render an image that'll have a source of ré URL. This is coming directly from the resume. So let me just dstructure it right here as well. And also give it an alt of ré and a class name equal to w full hash- 350 pixels on max small devices h of 200 pixels and object- cover as well as object dashtop. And here we can display the preview image but instead of a ré URL the actual image will be under image path which we can get as a prop right here through résé and then just say image path right here. If you do that you'll be able to see three different résumés rendered as images right here on the homepage. Also, if you head back over to the home, you can notice that right now it seems like we don't have any padding between the edges of the screen and the cards, which is never good. So, you want to make sure that this main section wraps the resumes as well. So, they're going to go inside of it on the homepage. And now that looks so much better on mobile, but also if you expand it to full screen, it looks pretty good. And if you head over to réséumés in the constants, if you want to, you can basically just duplicate these three to get three more and then just modify the ids to say four, five, and six. If you do that, you'll be able to get a glimpse of how our final application will look like once we implement the ré rating functionality. Let's also give this hero section some breathing room by heading over into our homepage and giving this page heading another class name of something like padding Y of let's do maybe 16. There we go. So now it floats nicely at the top of the screen and then we can explore all of these résumés below. With that in mind, we are now ready to dive into creating the primary functionalities of our application. Now that we have the UI and that of course starts with implementing the authentication because before someone can upload their resume and request feedback, we need to know who is requesting feedback so that we can store it in some kind of a database and connect that user to that ré review request. So in the next lesson, let's dive right into the O. Okay, we're getting closer to handling the user data. So it would be great to know who it belongs to. For that, we're going to use Pewer. Head over to docs.putwer.com and check out this image that we have right here. This is our backend. No packages, no setup, just one small script and you get the O cloud storage, data storage, and AI integration. Sounds almost too good to be true, but let's actually follow the instructions and add the script to the root of our application. So, head over to getting started and copy the script. Then head over into our app and then head over to root.tsx. Here we have the layout and right here at the top of the body we can add this script that'll load putjs. So let's indent it properly and immediately we have all of the computer's functionalities. Now back within computer docs you can see that every single function is neatly explained. For example head over to cloud storage upload which is a function we'll use. And here you can very easily see what the point of this function is. You give it a number of local items and then upload them to the computer file system. You just have to provide an array of files to upload. So now that you know how works, I want to provide you with one extra file. It'll be right here within the video kit and it'll be called app liibuter.ts. Copy it and let's add it to our codebase. Within the app folder, create a new directory and call it lib. and within lib create a new file and call it puter.ts and paste the file you just copied. Now let me explain everything that is happening within the single file because it might seem like a lot but it's really not. First things first, you can probably notice there's a lot of red squiggly lines right here that says that some types are missing. Like before we can add those types by creating another type declaration file. So within the types folder create a new file and call it puter.d.ts which will contain only the puter types. I also provided that file right here within the snippets to copy types puter and simply paste it here. It contains things like the computer user the file system item what it needs to have as well as how the AI response should look like. And now you can see that this file is no longer complaining about anything. Okay. So what is this file all about and why do we even need it? See, after adding this script to our application, the API became available throughout the entire application. And you can call it for example within the homepage simply by saying something like window.puter. And if you press another dot, you can see how my tlesense automatically lets me know what I can access from the puter variable. But if you tried saying something like window.putwer.ai.hat and you called it, you'll see red squiggly lines saying that puter does not exist on type window. So for now, I will remove this and head over to our computer.ts. All of that works because I declared this global interface of window that defines all of the different functionalities that we can extract from puter. So, Typescript recognizes all of them within our project and stops complaining. That's this global declaration. Then, the sputu store is almost identical to the window above. This one is used by Zestand to define the store, a place accessible from anywhere in the app where we can store our data. In this case, we're storing Peter's functions. Okay. So, since we added the script to our application, we now should be able to do what I did just here, window.puter.ai. at and call it. It should work, right? The answer is yes, it works right off the bat. But every time checking if the script has loaded and then storing the authentication state between components and then managing it all would just cause us a lot of trouble and repeated code. That's why I decided to use Zustand as a wrapper and cache for put. Zastand is a small, fast, and scalable state management solution. In simple terms, it lets you create a global state using simple JavaScript functions. You can then define that state and then create a new hook called use store to access and update the state in your entire application without needing to pass the data between components. No need to worry about loading and keeping the states up to date. Everything is in one file and accessible by just one line of code in our components. So instead of just using the window which in React is not preferable, I created this puter.ts file with a function called get puter which is a sort of a shortcut to quickly get puter API inside of our functions without repeating the boilerplate code in every component or function where we need to access it. It simply gets access to the puter variable from within the window object. And finally, the biggest part of this file is the use computer store. It's a hook that essentially creates a zastand store and loads all the necessary functions within it. If you scroll a bit down, you'll notice that all of these functions like sign in, sign out, and so much more are basically just wrappers for Peter's functions you saw in the documentation earlier. For example, let's take a look at the upload. Here it is. We first get access to the computer object. We check if put exists and then we simply wrap it with computer.fs.upload. Looks similar. Well, that's because it is. It is the same thing that I pulled from the documentation, but in this case, I wanted to have access to it all within a single Zestan store, which is going to make it easier for us to use those computers functionalities later on. It accepts the same inputs, provides the same outputs, and I even named them the same so that you will never have to even open this file anymore. You can just refer to the docs and immediately use all of these different functions that I exposed right here through the Zustan store. But keep in mind that at all times, Pewtor is powering all of these different functionalities. Okay. So now that we have this wrapper that basically exposes all of the different types and this put store that gives us access to all of the functionalities from the puter library. We are now ready to start using puter within our application. So let's start by implementing authentication. First create a new route. That's going to be within app routes and create a new file and call it o.tsx. within it run rafce. And now that we have this new route, we can actually import it within the routes.ts file where we have this array where the index points to the homepage. But then we can also add a second route which is going to be forward/ for the path and then it'll actually point to the routes/.dsx. Now, back within our application, if you navigate over to localhost 5173/, you'll be able to see that we're on this new O page. So, let's go ahead and implement it. First, let's give it some metadata by saying export const meta is equal to an error function that automatically returns an array where it renders an object that has a title of something like resumind. And then we can also give it a description. So another object with a name of description and content can be set to log into your account. So now if you save it, you can see right here in the title that it says resum mind off. Good. Now we can focus on the layout of the page. I'll wrap everything in a main tag and give it a class name equal to. It'll be the same as it is on the homepage. We first set the background. We set it to BG cover minage screen and then we also apply some flex properties like flex item center and justify center as well. So the elements within it appear vertically and horizontally centered. Within it, I'll display another div with a class name equal to gradient-border and a shadow of LG. This will act like our form and within it I'll create another section with a class name of flex flex- call a gap of 8 background of white rounded of 2 XL and a padding of 10. And this will create what appears to be a form. Within it, I'll create another div that will render an H1 that says welcome. And below it, I'll also render an H2 that says something like log in to continue your job journey. There we go. Looking good. And we can also style this div by giving it a class name equal to flex flex- call items center gap of two in between the elements and text center. So now it looks much better. And we also want to create a couple of states to be able to track the state of the loading process. So you could create a new use state snippet and call it is loading. But in this case actually we already created it within the use store. So if you navigate over to the use store, the only thing we care about is what we are returning from it. So here we're already handling the errors, checking the odd state, signin functions, and all of these different functions. But the part that we care about the most is at the bottom where we check out the return of all of these functionalities. Here you can see that we're returning the is loading state initially set to true, but it also gets reactivated whenever we call some other functions and gets reset in case we're loading something in real time. This means that we can get access to the loading state directly from the computer store by saying const and then dstructuring the is loading and making it equal to the use computer store which we have to import from lib puter. No need for loaders. Checking if put script is present and has been loaded on the page. Just extract whatever the part of the API you need. B. Loading state file systems and you have it all right here within your application. As a matter of fact, I like this computer store that I created so much that I might even put it out on mpm as an additional puter react package. But yeah, it's nothing more than a simple wrapper around the original puter API. From here, we can also get access to the O object which contains the state of the user, whether they're authenticated, and the functions to sign the user in or sign them out. So right here below this div, we can create another div. And here we can check if we're currently loading. If we are loading, we can render a button that'll have a class name equal to O button and it'll have an always loading animate pulse animation and it'll say signing U in dot dot dot. We also need a second part of the turnary operator. if we are not loading and then we can render an empty React fragment. So you can see this is how it's going to look like. It's going to pulse if we're currently being signed in. But else we want to check if maybe we are already authenticated. If that is the case, we want to render a button that would allow us to log out. So right here I will create a button and say log out. I'll give it a class name of o button and on click I'll call osign out functionality. Also, if we're not currently authenticated, I will display the same looking button, but it'll have an odd functionality of sign in. And right here within it, I'll say log in. And both of these texts can be within a P tag. So, P. And we can end the P tag right here. And the same thing goes for the log out. Perfect. For now, it's still going to pulse because the is loading state is by default set to true unless we set it to something else. This page will also have to handle the redirection in case the user is already logged in. So, we can check that within a use effect. I'll import the use effect from React and create a new callback function with a dependency array. will recall the function whenever the is authenticated state changes. In here, we want to check if a is authenticated, then we want to navigate over to the next page, the page that the user wanted to get to. And that's a very nice UX trick that I want to show you. Whenever a user tries to access a secured route while not authenticated, we can redirect them back to O with the next query parameter. Then after successful authentication, we're going to then automatically redirect them back to the page they wanted to access in the first place. Let me show you how that works. You can say const location is equal to use location. This is coming from React router. Then you can say const next the page they wanted to visit next is equal to location dot search.split split and then you can put a string of next equal and then extract the first next page they wanted to visit. Then you can also get access to the navigate functionality which is equal to use navigate coming from react router as well. So now if is authenticated we'll simply navigate them over to the next page they wanted to visit. So we also have to add the next variable to this use effect as well. Perfect. So in simple words, this is a redirection. So if a user tries to access a secure route and they're not logged in, they're going to be blocked right here at the O. But after they log in, we'll simply redirect them to the next page they wanted to go to. And now we can do a very similar thing within the homepage. So, I'll copy this use effect and all of these different imports within the component and head over to the homepage. Here at the top, I will simply paste what I copied. We want to get access to the O object from the computer store as well as the navigate functionality. We don't need the next in this case. Then within the use effect, I'll check if not is authenticated. In that case, we want to navigate over to forward slash question mark next is equal to forward slash. Make sense? So basically they try to access the homepage which is the forward slash. So we're adding that as the next. But for now since they're not authenticated we're bringing them back to o with next as that next parameter. Pretty cool, right? So now if you go back to the homepage, localhost 5173, and reload, you'll be redirected back to the O page. For now, it appears we're stuck on signing you in, which means that the loading state within our O is equal to true. But why is that the case? Well, if you check the use computer store, which is our glorified wrapper of the puter library, you can notice right here that by default it is set to true until we call the init function. This init function will simply check whether Peter exists and then call the check off status which will then set the loading to false in either case whether the user is not logged in or whether they are logged in. So where can we actually call that init function? Well, we can call it in the root of our application right here where we have the layout right on top of where we're returning the JSX. Here I'll say const and dstructure the innit function coming from use store and then I can call a use effect and within it we can simply call the init function and as a dependency array we can pass the init function itself. although it won't change too much. So now as the init function gets called we verify that pewtor is there and you can now see that there is a login button. Let's actually expand this to full screen. If I now click login you can notice that we automatically get navigated over to Peter's well let's call it external computer allowing us to log in. I already had an account with pewtor but if you don't have one you can just create a new one. In this case I'll log in with my existing account. It says signing in. And here we are. We get redirected back to the homepage. Now, if you manually try to navigate over to for/ I made it possible for you to do that, but now you'll be able to see a log out button right here, which means that we're successfully logged in. And if you head over back to the homepage, you won't get redirected to the O, which means that you're successfully logged in. This means that we have successfully set up within our application. I made it significantly easier for us to use Peter's functionalities later on, which don't get me wrong isn't necessary at all. You could every time just immediately use all of the computer's APIs by saying Windows. But in this case, it'll just be easier for us moving forward by saying window.puter something like chat for example. That's because Pewtor is completely framework agnostic and you can use it within plain vanilla JavaScript. But just for convenience sake, I created this entire wrapper that we can use for this project specifically to make it a bit more convenient to handle the global store such as the user data, the is authenticated status loadings and more. So with that in mind, since the big part of the odd functionality is now done, let's actually go ahead and push it to GitHub by saying get add dot get commit dash m say authentication and then get push. In the next lesson, let's focus on creating this form that allow us to actually upload documents to Pewer's file system. And then later on, we'll use AI to review those résumés depending on specific job descriptions and provide us the reviews. Let's dive right into the upload page. Back within the code, create a new page right here under app routes and create a new file called upload.tsx and run rafce. Once you do that, head over to routes.ts and modify it by adding a new route route/upload. And then here you can point to the file you just created under routes upload.tsx. If you do that and then navigate over to localhost 5173/upload, you'll see that we now have this empty page that simply says upload. So, let's get started creating it. First things first, I'll wrap everything in a main section that looks very similar to the one in home where we start with a main and then have a navbar and then another main section. So, let's copy these three opening tags and I'll paste them right here. We start with the main have a navbar down there. Then we have a section and then we can close the main right here. So now if you save it, you'll see that we basically get the same layout that we had before. Then right within this section, let's create a div that'll have a class name equal to page heading. And then within it, we can render an H1 that says something like smart feedback for your dream job. And then we have to figure out whether we're currently processing the upload or not. So for that reason, make sure to import use state from React and then create a new use state snippet called is processing and set is processing and at the start set it to false. Right below the H1, in case we are processing, we can figure it out right here by checking if is processing is true. In that case, we want to render an empty React fragment with an H2 that renders some kind of a status text. And I'll put that in a new state snippet called status text. Set status text at the start equal to an empty string. So here we can render that status text. And then below it, I'll render an image with a source of forward slash images/resume dashcan.gif with a class name equal to wful full. So it takes the full width of the screen. And then if we're not currently processing, we can render just an H2 that'll say something like drop your resume for an ATS, which stands for application tracking system score and improvement tips. There we go. So now if we are processing, I'll set it to true for now. We have this scanning GIF which is very convenient right here to emphasize that something is happening. Then below this part, I'll render yet another dynamic block of code. And I'll check if it's not processing. So the other way around. In that case, we want to display a form. In this case, it's not going to be a turnary. I'll just say if not processing, we'll basically render this form component with an ID of upload form. An onsubmit equal to handle submit. This is a function that we have to create right here handle submit which accepts an event and for now is equal to a regular error function. But we can define the type of the event as form event and then specify that it's specifically an HTML form element like this. So now we know that it's basically a submit button. Then to this form we can give a class name of flex flex- call and a gap of four. And within it I will render our first div with a class name equal to form div. Within it I'll render a label. This label will have an HTML 4 company name. That's the first input field. And that's exactly what it'll say. Company name. Then right below it, I will render an input with a type equal to text, a name equal to company name, a placeholder equal to company name, and an ID equal to company dash name as well. And now we can see the input appear right here. We can also give this page heading a class name of padding Y of 16 to give it some breathing room. as well as to this form we can give a margin top of like eight to give it some space here as well. Now we can duplicate this form div a couple of times. First let's duplicate it once and this time we'll change the label to make it HTML 4 job-title. It'll say job title and then the name will be job title. The ID will be the same, job title, and then the placeholder will be set to job title. There we go. We can duplicate it one more time below, but this time it'll be for a job description. So I will automatically change it in all the places description as well as here and here description. And this will actually be a text area. So instead of type of text I will give it rows of five so people can provide more information about the job. And finally I'll duplicate it one final time. This time the label will be for the uploader. So I'll say uploader it'll say upload resume. And instead of a text area for now I will just render a div. And within the div I'll say uploader because later on here is where the real uploader component will go. And finally below it I will render a button that'll have a class name equal to primary button with a type of submit. So it'll actually submit the form that it is within and then it can say something like analyze resume. Perfect. So now the only thing that we have to do is to implement the file upload component that will allow us to upload PDFs that we can then analyze. So let's create a new component within the components folder which we can call file uploader.tsx run rafce and go ahead and import it within the form that we just created instead of this div. So I'll say file uploader like this. And now here it says file uploader. So now let's implement this file uploader component by heading over into it and starting with the UI. First I'll give this div a class name equal to wful and a gradient of border. There we go. So now it already looks like a real file uploader. Not quite yet, but we're getting there. you don't really want to code the file upload component on your own. It's one of those cases where you have to write a lot of code to handle the drag and drop logic and more. But thankfully other people have already done it before us. So there's a package called React Drop Zone which if I'm not mistaken has close to 5 million weekly downloads. Yep, that's right. And it is completely free to use. So you just have to install it and use it. So let's do that together. Right here in our second terminal, I'll run mpm install react- drop zone. And then we can figure out how to use it right here. Basically, you import the use callback hook from react as well as the use drop zone hook from use drop zone. Then you define what happens on drop as well as import some of the properties from the use drop zone hook. You can also open up this mpm package and copy these things. Finally, you define how this input is going to look like. In this case, we have this div right here. And within it, I will paste this div that has an input with the is drag active functionality. So, I just copy pasted everything that we have on here. We might refer back to this documentation for when we want to read using the file reader API. But now, if you just get back, it says drag and drop some files. Or if you click it, you can automatically select some files from your file system. But now we got to figure out what happens once you actually put them in. And of course, we have to make this component look just a tiny bit better. And when we do upload a file, we want to show how it looks like. So I will remove this is drag active. And I'll actually code this part myself by creating a new div that has a class name equal to space y of 4 as well as a cursor pointer so people know that they can click on it. Within it, I'll render another div. And within that div an image that'll have a source of forward slashicons slashinfo.svg with an al tag of upload and a class name of size of 20. We can style this div a bit better to center this icon with a class name of MX auto W of 16 H of 16 flex items center and justify center as well like it's waiting for the upload to happen and then below this div if a file exists. So file in that case we want to render a div that looks something like this. But if a file doesn't exist, in that case we want to render another div. And of course, this file will be stored within the state. So right here at the top, I'll create a new use state snippet and call it file and set file. Of course, don't forget to import use state from React. So right now, we haven't uploaded any files. So in that case within this second div, I'll render a p tag with a class name equal to text-lg text-g gray 500. Within it, I'll render a span with a class name of font- semibold. And it can say something like click to upload. And then outside of the span or drag and drop. And then outside of this P tag, we can render another P tag with the same class name of text-LG and text-g gray 500. We can render the PDF and say something like max 20 megabytes. There we go. So now it's very clear that we want the users to upload PDF files right here with a max file size of 20 megabytes. Okay. But if they have actually uploaded something like I uploaded the resume right now but we can't actually see anything because we're not yet handling the uploads. So this means that we have to implement the functionality on drop. What happens once we drop the files? So first of all I'll define the type of the accepted files. by saying it's a type of file array like this. And then we can get access to it by saying file is equal to accepted files zero or null if nothing was passed. And then I want to call the onfile select which is a function that we're going to pass as a prop to the file uploader. So let's dstructure on file select and this is going to be of a type file uploader props which we can define right here at the top interface file uploader props on file select will be optional and it'll be a function that accepts a file of a type file or null and doesn't return anything. So now we know we have to pass this to the file uploader component. So back in the upload.tsx component, let's actually create this new function that will handle the uploads. I'll call it const handle file select. It'll accept a file either of a type file or null. And the only thing it'll do is it'll set the file to the state. So we want to be managing the file state right here in this component. So in the upload page I'll create a new file and set file state at the start equal to null but it can be of a type either file or null. And once we call this function I simply want to set file to the file that we drag and drop into that drop zone. And now we can pass this handle file select over to the file uploader component. That'll be right here on file select handle file select. Perfect. So now once we drag and drop it, we can actually accept it right here through props. And then we can call on file select and pass in the file we just dropped. You can add a question mark dot right here in case we forgot to pass the onfile select function just so something doesn't break. And we will modify this onrop function whenever the onfile select function changes. Perfect. Now use drop zone also gives us all of these different options. Root props, input props, is drag active. And it also gives us access to the type of the accepted files. And we can also pass some options. For example, right now we're passing just on drop, but we can also say something like multiple will be set to false. We're only accepting a single resume. We can also say which types of files we accept like an object of application PDF. Specifically, it's going to be a PDF extension. And we can also define a max size of something like 20 * 124 124 which is basically 20 mgabytes. Now we can get access to the actual file by saying const file is equal to accepted files zero or null. And if we define the file right here, we're actually getting it through the accepted files. It doesn't even need to be in the state because the use drop zone functionality will be handling that file upload. Next, I want to be able to format the size of the file that got uploaded. And this is typically a huge function that deals with a lot of math in order to be able to show it nicely. So it might be the perfect opportunity to ask Juny for help. I'll just press commandshiftb and then type juny to open it up. And I can tell it to create a format size function which accepts a number in bytes and returns a human readable string indicating the size in kilobytes, megabytes or gigabytes. Let's see how well it does. It created the entire plan and it's determining the best location to implement this format size function. It'll then update the file uploader component to use the format size function. It'll even test the implementation to ensure it works correctly, verify the changes meet the requirements, and then submit the changes. In this case, it's asking me to run the terminal command, but for now, I'll just say skip. I don't think it's necessary. It looks like it found the utils, the best place to implement this function. And now it's opening the file uploader and finding the best place to utilize it. There we go. The function has been updated to utilize this new functionality and it is done. We have the full explanation right here. But for now, I will just collapse it and try to see where it used it. So you can see if we head over to the util function that it created this new format size function and it even commented it out nicely saying that it formats a file size in bytes to a human readable string. It told us what we need to pass to it and what it returns. Perfect. This is looking good. And this is exactly the type of code that I really don't feel like writing right now. It used it right here where we're saying max and then max file size that we want to pass over into it. But for now, I want to use it in another place. I want to use it to indicate the size of the uploaded file. Oh, and it actually looks like it coded that part. So, if we do have the file, it's specifying the file name and the file size. It's like it knew that this was going to be my next step. So now if I upload a sample resume, you can see that it gives me the file name and the human readable file size. Pretty cool. But let's style it a bit better. I'll give this div instead of text center a property of flex items center and a space x of three. Then I will render an image that'll have a source of forward/ images/pdf.png PNG with an all tag of PDF and a class name of size of 10. This is to indicate that the user uploaded some kind of a PDF. And then I'll render another div right here. And within that div, I'll put these two P tags. The first P tag will render the file name. But let's style it a bit by giving it a text small font medium text gray of 700 truncate so the text doesn't jump out as well as max w extra small. And then for the second one I'll give it text small text grade 500 and render the file size. Now this is looking great but I want to put it within another div. So this entire div I'll put within a new div. indented appropriately because this div will have another class name equal to uploader selected file. There we go. And I'll also give it an on click and call a callback function where we want to call event dot stop propagation. What happens here is that once you click in it, it'll actually want to open the file as well as allow you to upload another file. But in this case, we already uploaded it. So, we just want to upload another file on click. Oh, and now we can put this image outside of this inner div just so it gets some more space. Now, if we have a file, we can actually hide this part right here. So, I'll only show it when there's no file right here within this other div. There we go. So, now we can see that there's only the file right here. But if I reload, everything is there. I can give it maybe a margin bottom of two. There we go. And then if you upload, you can see just the PDF as well as the name and the size of that file. Still below one and two more divs, we can create a button that allow us to remove that PDF from there. So the whole button will be just one single image with a source of forward slash icons/cross. SVG with an al tag of remove and a class name equal to W of4 and an H of four. There we go. And we can give this button a class name of padding of two as well as cursor-pointer. And we can on click create a new function. So on click I'll simply call the onfile select question mark dot in case it doesn't exist and pass in the null to reset the file we passed in. So now if you go ahead and click this X it goes away and you can upload another file. Great. Now that we've implemented this file uploader component, let's head back over to our uploader page and let's put to use this new file that now we have access to. Because remember once we pass it into the drop zone we save it to the state of this page and then we're ready to submit it. First things first I'll prevent the default behavior of the browser and that is to reload the screen. So e prevent default. Then I'll get access to the entire form by saying form is equal to e.current target dot closest form. This allows us to get the form data without necessarily relying on state. So I'll say if there is no form just exit out of the return function or submit function. But if there is data give it to me in this form data variable by calling the new form data and then passing the form right into it. From it we can then extract all of the important details like the company name, title, description and so on. So say const company name is equal to form data.get company dash name and we can duplicate this two more times. The second time I'll get the job title and I'll get it by the name of the job title and for the third time I'll get the job description which I'll get through job description name. And now we just want to console log all of these values to see if we actually have access to them. So I'll say console log within an object. It'll be a company name, job title, and job description as well as the file that we are getting when we upload it. So let me reload the page, open up the console, and type it all out. For the company name, I'll go with JS Mastery. Let's say that we're applying for a lead front-end developer. And now for the job description, you can literally copy the full job outline, like a whole long page, and just paste it here. For now, I'll just say something like looking for a React developer with five plus years of experience. And then either drag and drop or just select your resume. Once you do that, it'll be uploaded and you're ready to click analyze. So once you do, the form will be submitted and you'll be able to see whether you properly extracted all of the different inputs such as the company name, the job description, and the job title, which are all here, and then the file, which contains all the information about that file. Perfect. The form is working. Now, in the next lesson, we're finally ready to take all of that data in, take in the actual PDF file, upload it to computer storage, and then utilize Pewtor's AI services to generate a resume review and provide AI feedback. Very soon, we'll dive into the main part of the application, and that is creating the assessment of our resume when matched against the job that we're trying to apply to. But before we do that, there is one small utility function that we have to create. And that is a function that'll take the uploaded PDF and just turn it into an image. See, it's easier to display images right here within the cards rather than displaying the PDFs. So, we're going to continue right where we left off, and that is within the upload component. Instead of console logging the data, instead we'll first check if there is no file. And if that is the case, we're going to simply exit the function. But if there is a file and we have all of these other pieces of data, we want to create and call a special function called handle analyze. So const handle analyze is equal to an asynchronous function that'll accept one object and that object will contain everything we need about this job to resume connection. So it'll contain things like the company name also the job title, the job description as well as a file. And we can also define the types of these different properties like a company name will be of a type string. The job title will also be of a type string. The job description will also be of a type string. And then the file will be of a type file. Perfect. So now we know the types of all of these things and we can open up this function block. We'll call this handle analyze right here at the bottom of the handle submit. Just like we called the console log, we're going to pass to it everything from the company name to the job title, job description, and finally the file. And at the end of all of these three lines, we can just add as string. So the typ script knows that we're working with strings and it's not going to complain right here. So now we can collapse the handle submit function and just focus on the logic of handling the analysis of the résumés that we upload when matched against the company name, title, and description. So first things first, we want to set the processing state to true. So set is processing to true which will allow us to show a nice loading animation. After that we want to set the status text to say something like uploading the file dot dot dot so that users can see that the app is working and they can know exactly what is happening at any given point. Then we want to upload the file to the computer storage by saying const uploaded file is equal to await fs dot upload and then we pass an array containing this one single file. Now where is this fs coming from? Well, it's coming directly from use store. Right at the top I can say const and then the structure the O the is loading state the FS AI and KV and this is equal to the use computer store. I'll show you very soon how we can make use of all of these functionalities. FS stands for file storage. AI is AI and KV stands for key value storage functions. We'll also need to navigate to other pages from this page once we upload the file. So I'll also get access to the navigate functionality by using the use navigate hook which is coming from react router. And now we're successfully uploading the file to the computer storage. But if we haven't uploaded it, so if there is no uploaded file in that case we can simply return set status text to something like error failed to upload file. Perfect. Now if we passed this if statement then that means that we are getting to the next step. So we can update the status text which will now be converting to image. We will keep the original PDF of course for analysis but we also want to convert it to image so we can nicely display it within our cards. So we can say const image file and make it equal to await convert PDF to image and then pass the file. Now we don't yet have access to this convert PDF to image function. So let's comment out this line and let me show you how I got it implemented. You can open up your file explorer and then head over to lib. within lib create a new file and call it PDF to image.ts and here we have to implement a file that'll convert it for us. Now once again this is a perfect use case for Juny while I was developing this application I used Juny to go ahead and implement this transformation from a PDF to an image and just so we have the same consistent code I'll provide it to you right here in the video kit down below PDF to image and then you can paste it. What we're doing is first loading this PDF and then once we load it, we then create this convert PDF to image function where Juny conveniently wrote everything I need to be able to take a screenshot of that PDF and convert it to a PNG image. Pretty convenient, right? So now we can uncomment this and import convert PDF to image from lib PDF to image. After we convert it to image, we can then check if an image file exists by saying if there is no image file file. In that case, we can return set status text and then instead of saying failed to upload file, we'll say failed to convert PDF to image. Now we're moving to the next step. So let's update the status text accordingly. And we can say something like uploading the image. So once we actually generate the image like we uploaded the file, we also want to upload the image. So I'll say const uploaded image is equal to await fs.upload and to it we want to pass an array that has the image file as the only file that we're passing in. Once again we're uploading it to computer storage. Then we want to check whether an uploaded image exists. For that, I can just copy this line right here and paste it. If there is no uploaded image, we can say failed to upload image. And now that we're done with the uploads, we can actually set the status text to something like preparing data dot dot dot. And we can generate a new unique ID for this AI analysis by saying const uyu ID is equal to generate uyu ID. And this one we have to import from utils. So head over to utils. For now we don't really have anything in there besides this format size function that was created for us. But basically here we can just say export const generate UU ID make it equal to an error function that automatically returns crypto. You don't have to import it and you can just say dot random UU ID. Perfect. So now if you head back over here you can just import that generate UU ID coming from utils. And now we can put it to use by formatting all the data such as by saying const data is equal to id equal to uyu ID. Resume path is equal to uploaded file.path. Then the image path is equal to uploaded image.path. The company name will be company name. Then the job title and the job description, all of those necessary things. And then finally, we have the feedback, which for now I will leave to be completely empty, but later on we'll fill it with an AI analysis. And now that we have this data object, we can use Peter's key value storage to set it on there by saying await KV set in a template string resume with a specific UYU ID and then to it we want to attach JSON.stringified data. After that, we can set the status text to something like analyzing. And then we are ready to generate the feedback using AI. It's easier than you might think. Just say const feedback is equal to await AI.feedback. This is a function coming directly from computer or actually let's look into it. This AI feedback if you look into it within our puter store you'll notice that this function is basically using puter's AI chat functionalities and behind the scenes we're using claude sonnet 4. The first parameter we have to pass to it is the uploaded file.path. So we give it some additional information and then the second one can be a string of instructions that we want to give over to the AI. So here you could say something like you are an expert in ATS applicant tracking system and resume analysis and then we can give it more information so it properly analyzes and gives feedback to your resumes. Now just so we don't have to type this entire message by hand I actually prepared it within constants. You should already have it here. If you head over to constantsindex.ts s you'll see a function called prepare instructions which takes in the job title description and the AI format and then it explains in a bit more detail how the response should look like you're an expert analyze and rate this resume and suggest how to improve it the rating can be low if the resume is bad thorough and detailed don't be afraid to point out any mistakes if there's a lot to improve give low scores this helps the user to improve if available will use the job description for the job user is applying to give more detailed feedback and take the job description into consideration and then we feed it in both the title and the description and then this is very important. We provide the exact format in which we want the AI to respond. It is an interface of feedback with the overall score ATS any tips tone and style content and so on because this will be super useful for us using this feedback later on within our application and then we wanted to return it in the JSON object without any other text or without back text. This will just make it so much easier for us to actually display on the page later on. So now instead of this short string we can just call this prepare instructions function and then to it we can pass the job title job description and oh I don't even think we need to pass the third parameter which is the AI response. We can remove it because AI response is already a part of the constants. So immediately we have access to it right there. So now you can see that it's good and we're passing to this AI chat functionality coming from puter both the path to the file as well as the message. So finally if we don't get any feedback so we can say if there is no feedback that we get back we can return the status text of error failed to analyze resume and this was supposed to be set status text. But if we have passed that step, we can extract the feedback that we got by saying const feedback text is equal to. And now we want to check if typ feedback dossage.content is triple equal to a string. If that is the case, then we can very easily extract it by getting it from feedback message.content. else. Maybe the feedback is not a string but an array. And in that case, we'll have to get it from feedback message.content zero to extract the first piece of feedback that we're getting. Oh, and it looks like it's asking us what's happening if we don't have feedback. But at this point, we do know we have it because we're checking for it. Oh, I made a mistake here. We wanted to check if there is no feedback, then return this. So if we check it like that, it knows that there must be feedback at this point in time. Great. And then if this is an array, we have to say text to extract the text from it. Perfect. Now we can take that feedback and add it to the data object that we had above. This one right here. Because at this point we left it empty, but now we actually want to append it there. So I will say data.feedback feedback is equal to JSON.parse parse and I'll parse the feedback text. And then we want to add the AI feedback to the data object and update the values of our key in the key value store by saying await KV set for this specific resume with this ID. Just JSON stringify the entire data object one more time. Finally, we can set the status text to something like analysis complete redirecting. And for now, we can just console log the data. Perfect. So, what do you say that we give it a shot? Let's say that we are applying for a position at Top Dog Law as a full stack web developer. Or you can head over to LinkedIn and copy the full job description like I did right here. It doesn't matter that it doesn't look structured. AI is just going to take it in and make sense of it. So for example, this is a legal firm and they mention what they have achieved and they ask you to write clean code and clean UX. Okay, they also need some marketing done. So now the AI ré tool should give us all of these insights and tell us how to optimize our specific resume. So I'll drag and drop this John Coder resume and click analyze. Okay, so here you can see different statuses. It uploaded the resume and it uploaded the image, converted it, and now it is at the analyzing step. Now, if the analysis is taking too long or if for some reason it gets stuck right here, like it did for me, then you might want to head over to the computer.ts file and try to play with different models. Like, let's try to use a claude 37 sonnet. And let's see if this model has any more luck. and let's see if it works better with this model. So, I'll just head back over here, reload. I've entered the same data as before. And now, let's analyze it. You'll be able to see all of the different steps right here from uploading the files to then analyzing the document. And we can see analysis complete redirecting. Of course, we didn't yet provide the complete redirect, but if we now open up the console, you can check that there is an object. And if I zoom it in a bit, you can see that we have all of the info we passed in, such as the job description, title, and company name. But we also have some additional things like the path to the image which was a PDF that we converted over to a PNG, the path over to the uploaded PDF itself, and then most importantly the feedback that we received, the final ATS score of about 75 out of 100 with some tips, what is good and what can be improved. We also have feedback on specific parts of our resume such as the contents with tips to improve as well as the skills, structure, tone, and style. Now, we can browse through them very quickly and see what these tips are saying. The resume doesn't convey passion. Okay, that's that's about the tone and style. We have to also add the achievement metrics. Okay, that's good. And use more action verbs. Sure, those are always good. But what about maybe the skills? If you take a look at the skills, you'll see that this job description emphasizes Google Tag Manager, Google Analytics, and marketing automation platforms, but these aren't mentioned in the skills section. So, this is super useful to know. It means that either you're not a good fit for the job, in which case you should not be applying in the first place, or maybe you forgot to mention those skills, or maybe even better, you don't know those skills yet. But now that you've received the feedback from ResMind, you're actually going to go and learn how to use those platforms very quickly and then modify your resume to suit the job better. Perfect. Same thing here for dimension of landing page experience and the UIUX collaboration skills. This is perfect. Exactly what I wanted to see. But of course, seeing it in a very simple string or object type format is not super useful. So in the next lesson, we'll put this JSON object to use and instead of console logging it, we'll pass it over to a completely new page that'll allow us to display all of this information in a meaningful way. So let's go ahead and commit it by saying get add dot getit commit-m. And in this lesson we just implemented cloud storage PDF to image conversion as well as key value storage and AI feedback. This one was packed. And then just type get push. Perfect. Now in the next lesson we can finally put all of this great data to use. Now that we've uploaded a resume and provided an AI analysis, we can actually take it and transform it into this complete ré review page where we can have all of these different collapsible components that rate our resume on a couple of different categories. So, let's do that. Next, we can start by creating a new page. Right here in the routes folder, we can create a new route and let's call it ré.dsx, run rafce. And then we can quickly modify the routes.ds file to include this new route. That's going to be a route to a path of forward slashres and then forward slashcolon id because it's going to be a unique ré which means that it's a dynamic segment of the route which reads the data straight from the URL and we can point it to routes ré.tsx. Now, if you head over to your URL and type localhost5173/res1, you'll be redirected to the réé details page. It says ré right here on the top. So, if you head over into it, let me show you how you can extract this dynamic parameter. Right at the top of the component or page you can say const and then dstructure the ID coming from use params which is coming from react router. Then you can just say that this is a resume of a specific ID in this case ré 1 which of course is fake as we have a much more complicated UU ID to denote our resume details but for now it's good enough that we can code the UI of this page. So instead of displaying just a fake number one right here, we actually want to head back to the upload page and instead of console logging the data or alongside it, we can also navigate to slashres/ uyuid. And this after we create the resume will bring us to a real ré details page. To be able to test it out, we have to head back over to the upload one more time and then enter some new information. For the time being, I'll just paste all the previous values and upload the resume. And let's go ahead and analyze it. This time we should actually get redirected to the right UU ID. So first it's going to upload a file, convert the image, upload the image, and finally it'll prepare the data, analyze it, and after matching our job description against our resume, it should redirect us to a new resume details page. There we go. Analysis complete. Redirecting. But it looks like we didn't get redirected yet. Let's see why is that. We do have the ré route. And under routes, I did say ré ID. It is possible that we might need to reload our application with mpm rundev one more time for this new route to be recognized. So I'll do that. And I'll just rerun the analysis. And after the analysis, I got redirected to the resume with this specific ID. Perfect. Now, the goal is to turn that empty white mess into something that looks more like this, where we show the image of the resume on the left, and then we show a complete resume review on the right with a couple of very cool components that very clearly explain what we need to do to actually land the job. So, let's make it happen. I'll head over into the resume page and first define some metadata. I think we can copy the metadata from our O page. Here it is. And paste it right here at the top. It's going to say Resmind with a description of something like detailed overview of your resume. And now we can immediately focus on the layout. So, first things first, I'll wrap everything in a main tag and give it a class name equal to exclamation mark PT as in padding top zero to reset it. And within it, I'll create a new nav component. And this nav will have a class name equal to ré nav and it'll have a link. This link of course is coming from React Router and it'll point to homepage if we want to go back and it'll have a class name equal to back button within it. We can render an image that has a source of forward slashicons/back. SVG with an al tag of logo and a class name of W2.5 and H2.5 as well. It's a little back arrow. And then we can also render a span within which we can say something like back to homepage. And we can style it a bit better by giving it a class name of text-g gray-800 text-s and font- semi-bold. There we go. Now, below the nav, let's render another div that'll have a class name of flex flex- row wool. On max LG devices, it'll be flex call reverse. We use this so that on mobile devices, we show some more important content first because we cannot fit both of the things at the same time on mobile. But on desktop, we can show them on left and right. And then within this div, I'll render a section. This section will have a class name equal to feedback dash section. I'll also animate it by giving it animate dash in fade dash in throughout a duration of 1,000 milliseconds with a gradient border on max small devices margin of zero H of 90% on max 2XL devices H fit and W fit Actually, for this section, I'll just keep the feedback section and we can copy the rest of the classes within a div that's going to be within it. So, right here, I'll first check whether the image URL exists and whether a resume URL exists. So if we actually have the uploaded resume and if that is the case only then do we want to render a div that'll have a class name equal to these different classes that we just coded out. But of course right now we don't yet have the image or the resume URL. The question is where are these coming from? We have to somehow load the data about our current resume. Right? And to do that we can use a use effect. So we load it immediately and to that use effect we'll pass a dependency array of ID. So simply recall this function as soon as we get access to the ID of the resume we want to fetch. Then we can create a new asynchronous function within the use effect which we can call load ré which is going to be equal to an asynchronous function. const ré is equal to a weight and now we want to load that resume from the key value store coming from puter. So right at the top I will get access to a couple of things from puter such as the o is loading file system and key value storage and make that equal to use computer store. Then I'll await kv.get get and I'll get access to ré under a specific ID like this. This will give us access to all of the résé data. Then if we don't get access to a resume, we can just exit out of this function. But if we do, we can parse the data that we received from it by saying data is equal to JSON.parse resume. And once we get it, we want to read from the file system. You can read PDFs or any other kinds of files by using something called blobs because files from computer cloud storage are returned as a blobs and we need to convert them into the PDF blob to PDF file and the image blob to image file. Let me show you how we can do that. const ré blob is equal to await file system read data ré path then if there is no ré blob we want to return then we can do a pdf blob and say new blob to which we pass an array of the ré blob and we pass a specific type such as the application PDF. Finally, from this PDF blob, we can extract the ré URL by saying const ré URL is equal to URL docreate object URL to which you pass the PDF blob and then we can set it to the state. So right here at the top I'll create two new state snippets. The first one I'll call the image URL and set image URL. And the second one can be resume URL set resume URL. And finally, the third one will be the actual feedback that we receive. And of course, since we're using states, we have to import it from React. Now, by default, all of these can be set to empty strings like this. And since we have a home button at the top, we also want to get access to the navigate functionality. So we can use navigation. So use navigate coming from React router. Great. So now that we have this ré URL, we can actually store it to the state by saying set URL ré URL. And now we can repeat the same thing with the images. const image blob is equal to await fs read data image path. If there is no image just return but if there is an image we want to get access to the image URL by saying URL create object URL from the image blob and then we want to set image URL to be equal to the image URL we just got. Finally, we can set the loaded data in feedback use state. So, set feedback is equal to data feedback that we're getting right here. After we create this load resume function, we can just immediately call it below by saying load resume. Perfect. So, now we should have access to all of these pieces of data such as the image and the resume URL. And we can actually try to display it. Let's further style this section by giving this feedback section a background. Let's do a URL of forward slash images/bg small.svg. Make sure to properly close it. And also give it bg cover h of 100vh so it takes the full height of the screen. Make it sticky and make it positioned right at the top. I'll also center it using the items dash center and justify dash center. So now we can actually display something within this div and that something will be an anchor tag and within the anchor tag there's going to be an image that'll have a source of image URL which we're now fetching from computer storage and it'll have a class name of w full h full object contain and rounded to excel and it'll also have a title of ré. Now, we would only be able to see this if an image URL and a resume URL actually exist. So, you know what? Let's actually at the end of load resume or load data when we set it and let's just console log all of these values such as the resume URL, image URL, as well as the feedback which is under data feedback. just so we can make sure we have all of the pieces of data. And already you can see that we indeed do have it because it appears right here on the screen. We have a photo of the full resume that we uploaded coming directly from computer storage. But not only that, right below I will actually add an href to this anchor tag pointing to the uploaded resumeé URL with a target of underscore blank. If you do this, not only can you see just the resume in the image format, which is super useful to be able to showcase it right here on the screen, but you can actually click on it and a full resume will be opened for you right here in the browser. Pretty cool, right? This is useful because images are easier to display. But maybe if the resume has multiple pages or you want to copy some text from it, it's always useful to open it up in a PDF format. Now we can head below this part or below this entire section and then we can create a new section beneath it. This is going to be the section for the feedback. So I'll give it a class name and it'll say feedback section and within it'll have an H2 that'll say resumeé review. You can see it right at the top. So this is what I meant when we wanted to reverse it. See, if I expand it, both things fit on the same screen. So, it's fine if it's on the right. But as we go lower, we actually want to show the resume review on top, not below, because it's what matters more than the image if we don't have enough space. Let's also style it a bit by giving it a class name equal to text-4xl text dash black and font-bold. right beneath it, we want to check if we have access to the feedback. So if feedback exists, then we want to display a div. But if a feedback doesn't exist, in that case, we want to display an image that will say something like source images scan 2. It's going to be this one, kind of like we're searching for it. And it'll have a class name equal to w full. So it takes the full width of the screen. But in this div we want to show the actual feedback. So within it let's say summary ATS details. And let's style it by giving it a class name of flex flex- call gap of 8 animate dash in fade dash in throughout a duration of 1,000 milliseconds. So if you save it now the details will slowly appear. One thing we must not forget to add is also the redirection. If for example the user isn't logged in then we need to navigate them over to the authentication page. We can do that by doing something similar we've done in the homepage. So we can just copy this use effect for the authentication and paste it right here on top of this use effect. But now instead of next being the homepage after they authenticate we want to point them to go to resume and then this specific resume ID like this. So let's turn this into a template string. And now that's good. And now by default this will turn on the loading. So we can say only if it's not loading and not authenticated then go here and we want to recall this whenever the is loading status changes. So now if you reload you'll first see the loading of the images and the PDFs. it says resume review and then as soon as it loads you'll be able to see your resume as well as the ATS details that we will soon display. Of course, this looks even better on desktop as this really is a desktop application. But of course, the app will really shine as we implement those additional components that actually tell us what we need to improve about this application. And for that, we'll need three additional components. So let's create them. Within the components folder, I'll create the first file and I'll call it summary.tsx and I'll run raftce. Then I'll create the second one and I'll call it details.tsx. Run rafce. And for the final one, I'll call it ATS.tsx. And I'll runce. Now we can head back over to the resume details page and right here where it just says summary ATS details, we can actually render those different components. I'll first render the summary. Make sure to import it as well. And I'll provide feedback to it as its first and only prop. Then I'll render the ATS score. to it. We have to pass the score itself equal to feedbacks.core or zero if it doesn't exist. And then I'll also pass the additional suggestions that we might want to show within that ATS score. For example, feedbacks.tips or maybe an array of no tips if for some reason they don't exist. And finally, I'll render the details component. To the details component, I want to pass the feedback, the same feedback object we passed over into the summary. Now, it looks like feedback doesn't know that it has access to this ATS type on it. So, right here where we define how feedback looks like, we can say that it can be of a type either feedback or null. And then by default we can set it to null but later on we'll fill it out with this full feedback object which contains the ATS which then contains the score. So now we have these three empty components but immediately in the next lesson we can implement them to get the full AI resume review. For now, let's go ahead and commit this by saying get add dot getit commit d-m. And in this one, we implemented the ré feedback page. So, let's go ahead and push it. That's it for this one. And then in the next one, we can dive immediately into the ré review components. Let's get started by developing the first component on the réé review list and that is the summary. So starting from top to bottom, let's give this div a class name equal to bg rounded-2XL shadow- md and a full width. This will make it appear like it's within its own card. Then within it, we can render another div that'll have a class name equal to flex flex- row items center P4 and a gap of 8. And within it, we also want to show some kind of a score meter like the one that we had on the homepage. If you take a look at the design, we want to have this gauge right here, which is basically a half circle. Here we had a circle, but here we just want to have something a tiny bit different. Since it works in the same way, let's go ahead and add it right here. Right within the components, I'll create a new component called score gauge.tsx and run rafce. Then we can import it right here within the summary score gauge. And to it we can pass the score equal to feedback overall score. The question is where is this feedback coming from? And the answer is pretty simple. It's coming from the prompts to the summary component because we passed it in. So we can just dstructure the feedback and say that feedback will be of a type feedback. Perfect. And we can close the score gauge component right here. Now, let's get over into it. And instead of developing it from scratch, you can just get over here and copy it since it's very similar to the score circle. It's basically an SVG component as you can see right here. And then below that SVG component, there's a very simple div that shows a score out of 100. And if you save it, you'll quickly be able to see a very simple gauge component. Now, below this score gauge, let's render another div. And this div will have a class name equal to flex flex- call and a gap of two. And within it, I'll display an h2 that'll simply say your resume score. And we can style it further by giving it a class name of text-2xl and font-bold. And then below it, we can render a P tag with a class name of text-sm text-g gray 500. And within it, we can render some kind of a text that says something like this score is calculated based on the variables listed below. And then we can list out some of the variables. Pretty cool, right? So we can head two divs down. And then we can start rendering different categories of the criteria that we used to rate the resume. Instead of just replicating it four times, I will turn it into a new custom component within this same component and I'll call it category. It'll accept the title of the category and its score of a type. Title is a string and a score is a number. And finally, we want to return some JSX like a div that has a class name equal to resume summary. And for now, we can just render the title within it. So now, right below this second div, we can render four different categories. The first category component will have a title of tone and style. And we'll simply pass the score from the feedback dot tone and style and close it right here. And now we can see it right here. We can also show next to the title immediately the score. Oops, but we didn't yet pass it. Score will have to be equal to a number. And we actually have to say score to this. Thankfully, TypeScript caught it. There we go. Tonin style 70. Now we can duplicate this one, two, three more times. The second one will be content of our resume. So it's going to say content score right here. The third one can be set to structure and then we can say structure. And finally the fourth one will be skills. So here we can say skills. So now if we save it you can see tone, content, structure and skills. Now let's make use of those values and display them nicely. Instead of just displaying a title and a score, we can actually make it make a bit more sense. For example, I will wrap all of this in a div that has a class name equal to category. And then within this div, I'll have another div that'll render a p tag that will then render the title of that category. And then below this div, I'll render another P tag which will have a class name equal to text-2XL. And this one will render a span with a class name of text color. So it'll actually be a dynamic property which we want to define right here because the text color will depend on the score. So I'll define the text color variable and say if score is greater than 70% or 70 in that case it'll be green. So text dash green 600 but if it's not then if the score is greater than about 49 in that case we can make it yellow. So then I'll say text- yellow-600. But if it's lower than 49, then it's red. So in that case, I'll make it text- red-600. And now we're using this text color right here to display the score out of 100. There we go. This looks a bit better. Now, let's still style it a bit more by giving this upper div a class name equal to flex. flex dash row a gap of two items dash center and justify dash center as well and let's not forget to make this p tag a bit larger by giving it a class name equal to text dash to excel and now we can see a clean differentiation of different scores and then finally a summary of the full ré score also we can display some kind of a score badge right below it so below Below this P tag, I'll create a new component which I'll call score badge. Not a gauge, not a circle, but a score badge.tsx. And for this one, instead of directly providing it to you, we'll actually generate it together using Juny. Or if you're not using Webtorm and Juny, then you can follow along. But I'll open up Juny right here. And then I'll give it some kind of a prompt. I already prepared some of it. I said create a small reusable React component called score badge and I'll say within score badge.tsx file. It should take a score number prop and display a badge with dynamic styles and label. If score is greater than 69 then green badge or maybe we can do 70 right here. Else if score 49 then yellow and then else we can say needs work. We can use different utility classes and the component should return a style div with a single P element within it. So let's ask Juny to code it for us and then we can actually use it right below the title P tag in the category part of the summary file. Let's see if it figures it out. So now it's going to think about it and then create the steps needed to approach this problem. There we go. Looking at the existing structure, the entire content of a small file was displayed for review. It already edited the score badge DSX. We can actually check it out. If we go into it, take a look at this. The summary file has been updated to import and utilize the score badge component integrating it with the existing category. Immediately the browser reloaded and now based on these scores, we actually get the badges that say good start or strong already. or if it was bad, it would say, "Hey, you need more work." So, this is the component that got generated. If you're not using Juny, feel free to pause the video and copy it over. But again, I don't see a reason why you would not use it because just it improves my efficiency by so much. And then the best part of all is that it automatically integrated it right here within the category component. Pretty cool stuff. And that concludes this summary component. Now we can head over to the second one and that's going to be right within resumeé. This time it'll be the ATS, the applicant tracking system score that we want to display next. The ATS score should look something like this. It's basically a rectangle that has a heading and then it gives you some more detailed information about where your resume is killing it and where it might need some more help. This is also just a very simple front-end component. So, let's see how Juny handles it. I'll open it up once again right here. And I already prepared another prompt for it. So, I'll paste it right here. If you'd want me to create an entire course or a video on creating prompts to improve your efficiency as a developer, just let me know. But in simple words, I said to create a React component called ATS inside this ATS file. It should take two props such as a score or suggestions. And then we want to render a card with a gradient background based on the score. So once again, we are diving into different scores that we have green, yellow, and red. We should display a top section that has an icon with different icons. And I believe that even if I wasn't so precise, saying what is good, bad, and so on, Juny would still be able to find those files and attach them properly. And then a headline, a description with a subtitle, paragraph, and a list of suggestions. So, let's see how well it does. By the way, if you don't want to type it all out or if you want to get the same output that I have, I'll still provide all of these three different components such as the summary, the ATS, and the third one right within the video kit. So, you can also copy them from there. I'll give Juny access to these SVG files and let it do its job. So, it first look into how some other components are implemented and then it created the ATS component with the required props and UI elements. You can see it right here. And now it's going to actually put it to use. It's making sure that the structure fits with what was asked and that it adheres to project structures. And there it is. It says it's done. So, let's reload the page and take a look at this component that was generated. It is super close to the final design. We can see the final ATS score and this score represents how well the resume is likely to perform in ATS systems. We need to add more relevant keywords for the job description and include a professional summary. This is exactly what I wanted to see. So, as I said, if you don't really feel like typing it all out, I'll provide it in the video kit or you can just use your AI agent to code it for you. But with that said, let's move over to the last component, which is the details component. We're going to have three separate accordians which you can expand and open up to be able to see a bit more information about your resume. It'll look like this. So all of the feedback that we're passing over from the JSON data, you'll now be able to see it and fix it in this nice format. So let's head over into the last component, which is the details component. And to start off with this component, we first need access to an accordion. So if you search for something like an accordion on Google or react or chaten, you'll quickly see what it is. It is basically a dropdown that when you click on it, you get access to some more info. Now you could actually get it from chaten or from some other platforms and then use it. But in this case, I just provided it right here. So we can immediately continue with working on what matters. So just copy it and create one final component called accordion.tsx. tsx and simply paste it right here. This one will need access to a special CN class name which is coming from Tailwind. So head over to utils and here you can create that function that Tailwind typically creates for you. You can just do it by saying export function CN which accepts the inputs of a type class value array and then you can just return TWW merge from Tailwind merge clsx which is its own package. So make sure to import it from clsx and then pass in the inputs. Again typically this is generated for you but for some reason it wasn't here in this case. And now the accordion is using that CN coming from lib utils. And now we can put it all to use by creating the last final UI component that's going to actually display the details of all of these different scores. This component is harder to implement than the two above because it has more additional data that we want to show on click and it's also making use of this additional accordion component. But still I want to see how Juny might be able to handle it. So let me open up Juny for this now more complicated task and let's give it a prompt. We're basically saying to create a details react component which should take feedback as a prop and display an accordion with four different sections. And then I provided a bit more information about what each of these sections should include. And I also told it that we can assume that accordion accordion item header and content are imported from here. So let's see how well it does. And as I said, I'll provide you with the final code either way in the video key down below so you can refer to it or even do it from scratch. Like if you don't want to use AI agents and you really want to practice to build this, that's totally okay. My goal for this course was to teach you the functionalities and the logic behind creating the resume analysis system. But if you want to practice some front end, that's totally okay with me. Pause the video right here. Take a look at the final design and try to build it. While you're doing that, I'll get Juny to do it for me. So, you can see it's actually searching for different icons and components so it can fuse it all together from the entirety of the codebase. There we go. It edited the details component with 200 lines. It's importing it all from the accordion, which is what I said. But more specifically, I think it should be coming from SLA accordion because we are already in the components folder. So, I'll save it. It says it did it. And for the moment of truth. And there we go. This is exactly what I wanted to see. It has created four different accordion elements. And if we expand it, we can see the feedback, what went well, and also what we need to improve alongside with more information. For example, this resume lacks quantifiable achievements. Adding metrics like increase site performance by x% or reduce load time by y seconds would definitely strengthen the impact. Also use some action verbs and make it more specific. But more specifically, I think the content part is where our AI ré analyzer really shines is because it analyzes the job description and figures out if this job requires specific knowhow that you didn't list in your resume. And if you then figure out that that is missing, you can tailor your resume to address those specific things that almost nobody puts on there, but you can. And you can actually learn those technologies. So Juny handled this in an amazing way. And the code is not gibberish. It actually looks super clean and well doumented, maybe even like I wrote it. So this is wonderful. Now, when I was initially developing it, it took me a couple of hours to get to this nice layout. So, I actually want to override this code with the code that I initially wrote and see if there are any differences. Okay? And you can do the same. I'll provide it in the video kit. It's going to be the details.x. So, simply paste it right here. And I think you'll have to modify the accordion import. And you can see that there are basically no differences. Maybe the text is a bit larger, but other than that, it is looking exactly the same. But of course, this is looking even better on desktop because here you can see your resume side by side with the feedback and it all just makes sense. Keep in mind that here it's talking a bit about Google Analytics, SEO, marketing, and so on. But that's only because this specific job requirements request you to have that. But for the same resume, if you pass different job requirements, you would be getting completely different type of feedback. So this application really stands out right now. Now the next step for us is going to be to head over to the homepage and to display these real résumés instead of displaying the fake ones that we had before when we haven't yet implemented all these functionalities. Oh, and don't forget to head back and push this code to GitHub. Just run get add dot getit commit m r resume feedback components and get push. That's it for this one. We've really done a lot. Great job. Let's go ahead and replace these fake rums with real ones on our homepage. To do that, I'll head over within our home route. And instead of just rendering and mapping over these fake résumés, now we want to map over real ones. But to be able to do that, we first have to fetch them. So right here at the top, let's create a new use effect right below this one. Within this use effect, we want to create a function called load resume equal to an asynchronous function. And then we want to immediately call it after. within it we want to fetch the image from the image path and to be able to do that we can access fs as in file system from the use computer store so then you can say const blob is equal to await fs read resume image path so we're trying to read the path of the image of the PDF if there is no blob we just want to return but if there is one we got to get its URL. So we can say URL is equal to URL.create object URL from this blob and then we can set it to the state. So right here at the top I'll create a new use state snippet and I'll call it ré URL set URL at the start equal to an empty string and you can import use state from react. Then we can simply set résé URL to be equal to the URL we just created above. And we can recall this function whenever the résé do image path changes if it even does change. But of course we cannot get access to the individual resume within the homepage. That has to happen within a ré card because we'll be fetching a new ré image and details for each one of these cards. So, I'll go ahead and copy this entire use effect and I'll move it over to the resume card component right here at the top. Make sure to import the use effect and everything else. You also need to get access to this FS the file system. And we can also copy this ré URL state which we can use then over in the ré card. So, just move that over here right at the top. And no longer will it be ré.image path here. We're immediately getting the image path as we're dstructuring it. So just say image path right here. And then get the file system from the use store. Perfect. Now here's one important thing that I want to mention. When you're uploading your resume, I didn't provide specific validations for the job description, title, and the company name. So you can only upload a resume. you don't have to add the other ones. You would do that if you wanted to get feedback only on your resume as a whole and not for a specific job description. So if we reach that state, we have to handle it properly because here we're expecting to have the company name or the job title. So what we can do is render these conditionally. I'll say only if the company name exists then render this H2. And in the similar way only if the job title exists well then render this H3. But if none of these exist right here within the same div we can say if no company name and no job title. In that case we can render another H2 which will be a bit generic. It'll simply say ré because that's your resume with a class name of text-b black. We can make it important as well as font dashbold. Perfect. So now we're handling that case as well. And the same situation might happen for the resume URL. So I want to map this entire thing only if a resume URL exists then actually render this div within which we're rendering the photo. So we're just doing some checks to make sure that nothing breaks within our application. Great. So now a ré card is looking good and it'll only display the images for those that have a ré URL. So now the last thing we have to do is head back over to the homepage and we have to load and fetch these résumés. So first I will get access to the KV key value storage from PWer store and then I'll also create two new states. The first one will be called résumés. So once we fetch them we can actually store them. It'll start as an empty array but it'll be of a type ré array. And then below it, I'll have a new use state snippet which is going to say loading résumés. So are we currently loading them or not? Which at the start will be set to false. Then after that we can create a new use effect that'll fetch all the résumés. I'll create it right below use effect. It'll happen only at the start. And we can have a function called load rumés equal to an asynchronous function. And we can immediately call it right below. Now within it we want to start to load the résumés and then we want to fetch them by saying const résumés is equal to in parenthesis await kv.list and list all the résumés doesn't matter the ID. So ré colon asterisk and then just set it to true. And finally, outside of the parenthesis, you can say as KV item, so we know the type of these résumés, specifically KV item array because we're going to be getting more out of it. Once we get them, we want to map over them and parse all the data by saying const parsed résumés is equal to résumés question mark. we get each individual resume and for each one we want to automatically return so just put parenthesis here and not curly braces JSON.parse parse of the résé dot values and we can return that as résé. It's going to be value not values. Type script save me here. Perfect. Now we can set those parsed rums to the state by saying set résumés. And either it'll be parsed résumés or just an empty array if something went wrong. And then finally we want to set loading résumés to false because we're no longer loading them. So now instead of mapping over the false résumés, we can first check if we're not loading. So not loading résumés and résumés.length is greater than zero. Then we can map over them. So remove the import for the previous résumés coming from constants. So it knows it needs to use the ones coming from the use effect. Then we might as well console log them once we fetch them. So right here I'll say console.log log parsed résumés and I'll reload. And if you check it out, it looks like we're getting back an empty array. And I think that's because I said résumés ID, but instead it should have been ré ID. If you fix it and reload very quickly, you'll see that we'll get back five real résumés. And you'll see that none of them seem to be rendering the ré images. Okay, we'll check out why that is. But before we do that, let's just add some additional loading states. So while they're loading, we can show that we're loading. And if there are none, we can show a button to upload a résé for the first time. So here, right below the H1, I'll open up a new block of code and check if we're not loading RSés and if résumés.length is equal to zero. If that is the case, we can return an H2 similar to this one, but it'll say something like, "No rumés found. Upload your first resume to get feedback." And if we have some résumés already, then we can render another H2 that'll say, "Review your submissions and check the AI powered feedback." In this case, that's exactly what we can see. Now, right below this div, let's also create a loading state by saying if loading résumés, then render a div. And within the div, I'll render an image that has a source of forward slashim images/resumecan2.jif with a class name equal to w200 pixels. And we can style this div by giving it a class name of flex flex- call items-c center and justify- center as well. So now if you reload it'll first sign you in and then we can see the loading state. This sometimes does take some time and then we can see them loaded right here. Now, if we don't have any résumés right at the bottom below where we're rendering them, we can also check if we're not currently loading and if the résé's length is equal to zero. In that case, we can render some kind of a button like a div with a link that'll point to forward slashupload. So, we can upload and check our first resume. So, I'll simply call it upload resume. I'll also give it a class name equal to primary button with a w fit text- XL for extra large and font semibold. And we won't be able to see this one because we have some other portfolios. But let's also style the div by centering everything and giving it a class name of flex flex call items center justify center and we can also give it margin top of 10 and a gap of four. So if the user is visiting it for the first time and we'll test this out later you'll be able to see a button to create it right on the homepage. But now let's deal with the more important problem and that is why can't we see any images within the ré cards. Let's head over into the ré card and see how we're fetching it. So right here we're saying, hey, try to read this image path from the file system. Then create a new URL object from this blob that we got and then set it to the state. After you do that, we should have access to it right here under ré URL. And then we are checking whether the réé URL exists. And if it does, what we can do is automatically render the ré URL because that is the actual image, not the one coming from props through image path. If you save it, you will now be able to see all of the different uploaded résumés. And you might be asking yourself, but why do we have so many? We only tested it out successfully a couple of times. Well, while I was testing it out, I might have created a couple more. So, now we'd have to somehow find a way to clean up some of these résumés from the homepage just so we can have a blank slate and start uploading résumés for real now that the full functionality has been implemented. So, we'll do that in the next lesson. For now, we can get it pushed to GitHub by saying get add dot get commit-m fetch real resumes on the homepage and get push. Perfect. Let's implement the functionality that allow us to wipe out all of the existing ré reviews which we don't really need. To implement it, you can create a new route in the routes folder. and you can call it wipe.tsx. Now, since this isn't something that we're going to actually show to our users, it's just something that we're implementing for us, it doesn't necessarily have to look that good, and I'll provide it to you within the video kit down in the description. So, you can just paste this wipe app functionality within the wipe.tsx. Basically what it does is it loads all the files and then it'll go through all the files, delete them and flush the entire key value storage. Now we can actually render it within routes by creating a new route. We can access it by going to wipe and it'll be routes wipe.tsx. So if you go to localhost 5173/wipe, you'll see a super plain page that says loading at the top. And once it loads, you'll be able to see all of the existing files. The whole goal of this is just to be able to wipe it out. So, let's click wipe app data. And now that I've waited a bit and reloaded, it looks like it properly cleaned up all the files. So, now if I head back over to localhost 5173, the homepage, you'll see that it's first going to sign us in and authenticate us. And since there are no résumés found, we can upload our first resume to get started. So, let's do just that. This time I'll go with another company called Charlie Health for a position of a web developer. And then I'll paste the entire job summary where it talks a bit about how this is a behavioral health clinic focused on connecting individuals to life-saving treatment. And the web developer here needs to work on WordPress. Oh, I wouldn't like that job. But let's see how our resume matches what is in the job description. I uploaded a sample resume and I'll analyze it. Converting, uploading, preparing the data. I'll zoom it out so we can see it in its full glory. And finally, it's analyzing it. And finally, we get redirected to the ré view. Sometimes pewtor is a bit slower, but in other times it works lightning fast. And if you check out the resume review, it says that our score is very very low, just 35 or 40 out of 100. It's missing relevant technical details for web developer position, no technical education. The resume format contains instructional text that will confuse ATS systems and it lacks industry standard sections like technical skills and projects. Yeah, basically it's just mentioning career objectives and more. So, when it comes to the tone and style, it's good. But when it comes to the skills, it basically didn't mention any skills that are required in the job post. Perfect. Now, if we go back to the homepage, we can see this Charlie Health web developer position resume review. And the app is basically ready at this point. As you saw during the build, it isn't a big one. When it comes to the UI, it's just four different pages with some components on top. The Peter wrapper file, the one I created right here, is the biggest file, but honestly, you could run the whole thing without it as well. That said, putjs is a great fit for lightweight personal apps like this ones. In a moment, I'll even walk you through how you can deploy your application within their app store. So, if you have similar ideas utilizing storage, file handling, and AI features, computer API and the whole web operating system could become your next go-to tool. So now that our app is ready, we can actually get it deployed. If you want to, you can go ahead and deploy this project on Versell, Netifi or some other platform. But in this case, I'll show you how we can deploy directly to Pewtor itself. First, let's go ahead and commit the changes. Get add dot get commit-m implement wipe functionality and get push. And now to deploy it over to put there's one step we have to make within our code and that is to head over to react routerconfig.ts and turn ssr to false. It's required for the build scripts to generate the app with index html entry point which is required for the deployment on computer. Then you can run the mpm run build command which will create an optimized production build. Then head over to puter.com. Open the app center and click add your app. You can even earn money as you publish the app right here. So select add new app and give it a name. Start with JSM and then do something like AI ré analyzer and click okay. Now if you reopen the dev center in some time you should be able to see your JSM AI ré analyzer. Head over to settings. It might take some time to load. And while it's loading, head back over to your application and find the optimized production build that has been generated for you. It is right here and it's called build. So just rightclick it and open in Finder or file explorer if you're in Windows. And then simply open it up and go to the client folder and then drag and drop the contents of the client folder in not the client or the build folder itself, but just the contents of the client folder. and then click deploy now. It'll take a couple of moments and then your app just got deployed. So now if you click give it a try, you can actually open it up within your new virtual computer. Just how cool is that? You can also head over to the settings and update the title, the name, and even the favicon to include everything we had before. Description, category. There's a lot of stuff that you can do there. So if you have some cool idea for an app, put just might be the right place for you to deploy it on. Not only can you share your project with others, but thanks to Pewer's incentive program, you could actually earn money while doing it. Pewer team chooses the most popular apps using Pewer and deploy it on their store and shares the revenue they get from the usage with the authors. In other words, it's like Spotify but for developers. So, if you have that one idea that was always in your mind, but you never got around to doing it, well, now might be the chance, and you can use Pewer as your back end. You can read more about it on developer.putwer.com. So, with that in mind, you have just deployed your application. Not only is it deployed within the computer store, but it's also deployed within a new URL. So, you just click it and it'll actually share it. So you get your own deployed website that you can share with others hosted on puter.com and it works exactly the same as it did when we were developing it. Best of all is that you don't have to track the usage of other people or pay for it. They're going to pay for how much they upload. For example, you can check your usage right here in the top right corner by heading over to settings and then checking out the usage. Every person gets their own free usage for all the different kinds of AI models. Pretty cool, right? So with that in mind, congratulations on coming to the end of this course. You implemented your own application tracking system that provides a score and feedback on how you can improve. It's a very cool application that you can push to GitHub, put on your resume, and feature it when you're applying for different jobs. Maybe you can even joke around and say that you tested your resume when you were applying for their position as well. Hey, you never know. They might find it funny and actually give you a job. So once again, congratulations on coming to the end. And if you liked what you've seen in this video, then you're going to love what we offer on jsmastery.com. A list of full advanced ultimate courses and so much more if you become a member. Just head over to jsmastery.com and browse all the different courses that we offer. I'll see you there. 